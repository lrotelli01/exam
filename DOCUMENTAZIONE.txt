===============================================================================
                  SIMULAZIONE DELL'ACCESSO CONCORRENTE A DATABASE
                        Documentazione Progetto OMNeT++
===============================================================================

1. INTRODUZIONE
===============================================================================

Questo progetto realizza una simulazione di un sistema di accesso concorrente a
tabelle di un database utilizzando il framework OMNeT++ (Discrete Event Simulator).

Obiettivo: Valutare le performance di un sistema di database con accesso
multiplo dai clienti, implementando il modello readers/writers con controllo
di concorrenza mediante mutual exclusion e FCFS (First Come First Served).

Contesto: La simulazione analizza come il sistema risponde a carichi variabili
di letture e scritture provenienti da N utenti concorrenti su M tabelle.


2. DEFINIZIONE DEL PROBLEMA
===============================================================================

Problema:
  - N utenti concorrenti accedono casualmente a M tabelle di database
  - Ogni utente genera richieste secondo un processo di Poisson (rate λ)
  - Ogni richiesta è una LETTURA con probabilità p, SCRITTURA con prob. (1-p)
  - La tabella è selezionata secondo una distribuzione specificata (uniforme
    o lognormale)
  - Ogni accesso richiede un tempo di servizio S (fisso)

Vincoli:
  - Letture: Multiple letture SIMULTANEE sulla stessa tabella (reader lock)
  - Scritture: Accesso ESCLUSIVO (write lock), bloccate da lettori attivi
  - Code: FCFS per gestire le richieste in conflitto
  - Mutual Exclusion: Implementata mediante contatori di lettori attivi

Metriche di Interesse:
  - Tempo medio di attesa (dall'invio richiesta al ricevimento risposta)
  - Throughput (accessi completati per secondo)
  - Lunghezza massima/media della coda per tabella
  - Utilizzo di ogni tabella (fraction di tempo occupata)
  - Rapporto letture/scritture completate


3. MODELLO DEL SISTEMA
===============================================================================

3.1 Architettura
  - Network: Fully-connected mesh topology con N users e M tables
  - Comunicazione: Message-passing asincrono tra moduli
  - Timing: Discrete event simulation con simTime() in secondi

3.2 Componenti Principali

  USER MODULE (User.h/cc, User.ned):
    - Genera richieste di accesso alle tabelle
    - Parametri:
      * userId: Identificatore utente (0 a N-1)
      * lambda: Rate di Poisson per inter-arrivi (accessi/secondo)
      * readProbability: Probabilità di lettura (0 a 1)
      * numTables: Numero di tabelle nel sistema (M)
      * tableDistribution: "uniform" o "lognormal"
      * serviceTime: Durata fissa operazione (secondi)
      * lognormalM, lognormalS: Parametri distribuzione lognormale
    
    - Comportamento:
      * Pianifica accessi secondo processo Poisson di rate λ
      * Per ogni accesso: seleziona tabella + tipo (lettura/scrittura)
      * Invia richiesta alla tabella specificata
      * Riceve risposta e calcola tempo di attesa
      * Registra statistiche via signal mechanism
    
    - Output Signal:
      * waitTime: Tempo di attesa per ogni operazione (doppio)
      * readAccess: Conteggio delle letture completate
      * writeAccess: Conteggio delle scritture completate
      * accessInterval: Intervallo tra accessi consecutivi

  TABLE MODULE (Table.h/cc, Table.ned):
    - Simula l'accesso concorrente a una singola tabella
    - Parametri:
      * tableId: Identificatore della tabella
    
    - Stato Interno:
      * activeReaders: Numero di lettori attualmente serviti
      * writeActive: Flag se scrittore attualmente servito
      * requestQueue: Coda FCFS di richieste in sospeso
      * serviceEvents: Lista eventi di completamento servizio
    
    - Logica Mutual Exclusion:
      * Se writeActive=true: nessun nuovo accesso (bloccato)
      * Se activeReaders>0: nuove letture OK, nuove scritture NO
      * Se activeReaders=0 e writeActive=false: sia letture che scritture OK
      
    - Comportamento:
      * Riceve richieste dagli utenti tramite gate userIn[]
      * Accoda richieste non servibili immediatamente
      * Pianifica evento "serviceDone" al completamento
      * Invia risposta all'utente richiedente via userOut[]
      * Traccia metriche di performance
    
    - Output Signal:
      * queueLength: Lunghezza coda nel tempo (intero)
      * waitingTime: Tempo di attesa per operazione (doppio)
      * throughput: Totale operazioni completate (intero)
      * utilization: Frazione di tempo tabella occupata (doppio)

  NETWORK (DatabaseNetwork.ned):
    - Parametri:
      * numUsers: Numero di utenti (default 60, range 1-200)
      * numTables: Numero di tabelle (default 20, range 1-50)
    
    - Topologia:
      * Fully-connected mesh: ogni user connesso a ogni table
      * user[i] invia richieste a qualsiasi table[j]
      * table[j] invia risposte a user[i] che ha richiesto

3.3 Modello Temporale

Inter-arrivi degli accessi (per utente):
  Distribuzione: Esponenziale con rate λ = 1/T_inter
  Generatore: exponential(1/λ) in secondi

Selezione della tabella:
  Distribuzione uniforme: intuniform(0, numTables-1)
  Distribuzione lognormale: lognormal(m, s) mappata in [0, M-1]

Tempo di servizio:
  Fisso: S secondi (specificato da parametro serviceTime)
  (In estensioni future potrebbe essere casuale)

Tempo di risposta = Tempo in coda + Tempo di servizio


4. IMPLEMENTAZIONE OMNeT++
===============================================================================

4.1 Scelte Progettuali

Statistica Raccolta:
  - Course-standard: Signal mechanism (registerSignal/emit)
  - Registrazione: @signal e @statistic nei file NED
  - Aggregazione: Gestita automaticamente da OMNeT++ runtime
  - Output: vettori temporali (.vec) e scalari (.sca)

RNG (Random Number Generation):
  - OMNeT++ default Mersenne Twister (seeded da omnetpp.ini)
  - exponential(x), uniform(a,b), lognormal(m,s) built-in

Message Passing:
  - Formato: cMessage con parametri (userId, arrivalTime, serviceTime)
  - Kind: 0=READ, 1=WRITE (per distinguere a runtime)
  - Context Pointer: Traccia richiesta originale durante servizio

4.2 Struttura dei File

User.ned:
  - Definizione parametri di User
  - Dichiarazione 4 signal per metriche utente
  - Dichiarazione 4 statistic per aggregazione dati

User.h/cc:
  - initialize(): Registra signal, pianifica primo accesso
  - handleMessage(): Routing tra accessi e risposte
  - finish(): Registra statistiche aggregate
  - selectTableId(): Uniforme o lognormale
  - sendAccessRequest(): Crea e invia richiesta
  - processTableResponse(): Calcola wait time e emette signal

Table.ned:
  - Definizione parametri di Table
  - Dichiarazione 4 signal per metriche tabella
  - Dichiarazione 4 statistic per aggregazione dati

Table.h/cc:
  - initialize(): Registra signal, reset contatori
  - handleMessage(): Dispatch serviceDone vs nuova richiesta
  - finish(): Calcola e registra statistiche finali
  - processQueue(): Logica mutual exclusion
  - startServiceForRequest(): Pianifica completamento

DatabaseNetwork.ned:
  - Declares numUsers e numTables come parametri
  - Crea istanze user[numUsers] e table[numTables]
  - Collega fully-connected mesh

4.3 Gestione della Concorrenza

Algoritmo Readers/Writers (in processQueue):

  1. Se writeActive=true:
     - Return (tabella bloccata per letture e altre scritture)
  
  2. Processiamo coda FCFS:
     
     a. Se richiesta è LETTURA e activeReaders≥0:
        - Pop dalla coda, incrementa activeReaders, avvia servizio
        - Continua loop (altre letture possono entrarvi subito)
     
     b. Se richiesta è SCRITTURA:
        - Se activeReaders==0: pop, imposta writeActive=true, avvia servizio, break
        - Altrimenti: wait (blocca anche richieste dietro, per FCFS)

Questo garantisce:
  - FCFS: Ordine di arrivo rispettato (importante per le scritture)
  - Parallelismo letture: Letture concorrenti sulla stessa tabella
  - Mutual exclusion: Una scrittura = accesso esclusivo
  - Starvation-free: FCFS previene starvazione


5. DESIGN SPERIMENTALE
===============================================================================

5.1 Parametri di Configurazione (omnetpp.ini)

Scenario Base:
  numUsers = 60
  numTables = 20
  lambda = 1.0 (1 accesso/secondo per utente)
  readProbability = 0.8 (80% letture)
  tableDistribution = "uniform"
  serviceTime = 0.1 secondi

Variazioni Sperimentali:
  
  a) Read/Write Ratio:
     - p=0.5 (50% letture, 50% scritture) - Workload scrivere-intensivo
     - p=0.8 (80% letture)
     - p=0.95 (95% letture) - Workload leggere-intensivo
  
  b) Carico Utenti:
     - N=10 (basso)
     - N=60 (medio)
     - N=200 (alto)
  
  c) Distribuzione Tabella:
     - "uniform" - accesso equiprobabile a tutte le tabelle
     - "lognormal" - hotspot: alcune tabelle più frequenti
  
  d) Rate di Accesso:
     - lambda=0.5 (basso carico)
     - lambda=1.0 (carico normale)
     - lambda=2.0 (alto carico)

5.2 Metriche Raccolte

Per Utente:
  - totalAccesses: Numero totale operazioni completate
  - totalReads, totalWrites: Conteggio per tipo
  - averageWaitTime: Tempo medio attesa (secondi)
  - accessesPerSecond: Throughput percepito

Per Tabella:
  - totalServed: Operazioni completate
  - totalReads, totalWrites: Per tipo
  - maxQueueLength: Massima lunghezza coda osservata
  - avgQueueLength: Media coda (campionata)
  - avgWaitingTime: Media wait time (secondi)
  - utilization: Frazione di tempo occupata (0-1)
  - throughput: Accessi per secondo di simulazione

Sistema:
  - Tempo simulazione: Configurabile (es. 100-1000 secondi)
  - Warm-up: Primi 10% ignorati per stazionaryità
  - Replicazioni: 10-30 run per scenario (per intervalli di confidenza)

5.3 Calibrazione

Tempo di simulazione:
  - Minimo 100 secondi per regime stazionario
  - Ideale 500-1000 secondi per basse varianze

Numero di replicazioni:
  - Minimo 10 per scenario
  - 30 per risultati pubblicabili
  - Seed: Variegato per indipendenza

Analisi dati:
  - Intervalli di confidenza 95%
  - Test significatività tra scenari
  - Plots: Throughput vs carico, Wait time vs p, etc.


6. RISULTATI E ANALISI (Template)
===============================================================================

Per ogni scenario eseguire:

6.1 Throughput Analysis
  - Plotting: Throughput totale vs numUsers per ogni value di p
  - Atteso: Throughput quasi lineare fino a saturation
  - Saturation point: Dipende da numTables e readProbability

6.2 Wait Time Analysis
  - Plotting: Avg wait time vs carico (lambda)
  - Atteso: Increase sub-lineare fino a regime, poi esponenziale
  - Fenomeno: Coda cresce quando servizio diventa bottleneck

6.3 Read/Write Impact
  - Plotting: Avg wait time vs readProbability per scenario fisso
  - Atteso: Wait time diminuisce al crescere di p (meno conflitti)
  - Concurrency: Più parallelismo con letture dominanti

6.4 Queue Length Distribution
  - Plotting: Max e avg queue length vs carico
  - Atteso: Crescita super-lineare con carico
  - Bottleneck: Identifica quale tabella satura per prima

6.5 Utilizzo Tabella
  - Plotting: Table utilization vs numTables per carico fisso
  - Atteso: Inversamente proporzionale a numTables
  - Scalabilità: Aggiungere tabelle riduce contention

6.6 Distribuzione Geografica
  - Confronto Uniforme vs Lognormale
  - Hotspot effects: Lognormale concentra carico
  - Trade-off: Uniforme più equilibrato, Lognormale può migliorare hit-rate cache


7. CONCLUSIONI
===============================================================================

7.1 Contributi del Progetto

- Implementazione di simulazione DES per sistema database concorrente
- Algoritmo readers/writers con FCFS per mutual exclusion
- Valutazione di trade-off concorrenza vs bottleneck
- Metodologia di design sperimentale per sistemi di code

7.2 Limitazioni Attuali

- Tempo di servizio fisso (realtà: distribuzione casuale)
- Nessuna cache/locality (accesso sempre uniforme)
- Nessuna indisponibilità/failure dei nodi
- Network delay trascurato (assunto istantaneo)

7.3 Estensioni Future

- Tempi di servizio variabili (lognormale, Pareto)
- Modello di cache: Probabilità hit/miss basata su workload
- Hot-spot migration: Tabelle "calde" variano nel tempo
- Batch processing: Multi-statement transactions
- Load balancing: Redirect utenti a repliche tabelle
- Warm-up/cool-down: Analisi transiente vs stazionario


8. GUIDE ALL'USO
===============================================================================

8.1 Compilazione
  $ cd src/progetto
  $ make clean
  $ make

8.2 Esecuzione
  $ ./run -f simulations/omnetpp.ini

8.3 Configurazione Parametri (omnetpp.ini)
  [Config BaselineScenario]
  *.numUsers = 60
  *.numTables = 20
  *.user[*].lambda = 1.0
  *.user[*].readProbability = 0.8

8.4 Analisi Risultati
  - Vettori temporali: results/*.vec (importare in R/Python)
  - Scalari aggregati: results/*.sca (leggere con opp_resultfiles tool)
  - Plotting: gnuplot, R, Python matplotlib


9. RIFERIMENTI AL CORSO
===============================================================================

Concetti da Teoria delle Code (teoria_delle_code.txt):
  - Processo di Poisson per arrivi (Section: Queue Models)
  - Sistema M/M/1 e M/G/1 (generalizzazioni in analisi)
  - Distribuzione esponenziale inter-arrivi
  - Mutual exclusion in coda (reader/writer problem)

Concetti da Statistica (Probabilità.txt, statistica.txt):
  - Intervalli di confidenza per medie
  - Variance reduction techniques
  - Stazionarietà e transiente
  - Warm-up period analysis

Concetti da OMNeT++ (slides_stea2.txt):
  - Signal mechanism per statistiche (Sec. 37-46)
  - Message passing e event queue
  - Discrete event simulation engine
  - Module hierarchy e composition
  - NED language para struttura
  - cMessage per comunicazione


===============================================================================
Fine Documentazione
===============================================================================
