\chapter{OMNeT++ Implementation}

\section{Design Choices}
\begin{itemize}
    \item \textbf{Statistics Collection:} Uses signal mechanism (\texttt{registerSignal/emit}) via \texttt{@signal} and \texttt{@statistic} in NED files. Output in \texttt{.vec} and \texttt{.sca}.
    \item \textbf{RNG:} OMNeT++ default Mersenne Twister seeded from \texttt{omnetpp.ini}.
    \item \textbf{Message Passing:} \texttt{cMessage} with parameters (\texttt{userId}, \texttt{arrivalTime}, \texttt{serviceTime}). Kind: 0=READ, 1=WRITE.
\end{itemize}

\section{File Structure}
\begin{itemize}
    \item \textbf{User.ned}: User module parameter definitions and signal declarations.
    \item \textbf{User.cc}: Handles routing, distribution logic (\texttt{selectTableId}), and statistics recording.
    \item \textbf{Table.cc}: Implements the core logic via \texttt{processQueue()} for mutual exclusion and \texttt{startServiceForRequest()}.
    \item \textbf{DatabaseNetwork.ned}: Connects the fully-connected mesh.
\end{itemize}

\section{Concurrency Management Algorithm}
The \texttt{processQueue} method ensures FCFS and Mutual Exclusion:
\begin{enumerate}
    \item If \texttt{writeActive=true}: Return (table locked).
    \item Process queue FCFS:
    \begin{itemize}
        \item If request is \textbf{READ} and \texttt{activeReaders} $\ge 0$: Pop, increment \texttt{activeReaders}, start service. Continue loop (parallelism).
        \item If request is \textbf{WRITE}:
        \begin{itemize}
            \item If \texttt{activeReaders} $== 0$: Pop, set \texttt{writeActive=true}, start service, break.
            \item Otherwise: Wait (blocks later requests for FCFS).
        \end{itemize}
    \end{itemize}
\end{enumerate}